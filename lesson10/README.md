# Семинар: строки, даты, коллекции, регулярные выражения

### 1) Строки + регулярные выражения

Дан список строк:
`["Name: Ivan, score=17", "Name: Olga, score=23", "Name: Max, score=5"]`

Задача: с помощью регулярного выражения извлечь имя и число `score` из каждой строки. Сформировать список пар `(имя, score)`. Затем вывести имя с максимальным `score` и само значение.

### 2) Даты + коллекции

Дан список строк дат в формате `"YYYY-MM-DD"`:
`["2026-01-22", "2026-02-01", "2025-12-31", "2026-01-05"]`

Задача: преобразовать строки в даты. Отсортировать по возрастанию. Посчитать, сколько дат попадает в январь 2026, и вывести это число.

### 3) Коллекции + строки

Дан текст (одна строка):
`"apple orange apple banana orange apple"`

Задача: посчитать частоту каждого слова (словарь/мапа). Вывести все слова, которые встретились больше одного раза, в алфавитном порядке.

### 4) Регулярные выражения: проверка формата

Дан список строк:
`["A-123", "B-7", "AA-12", "C-001", "D-99x"]`

Задача: оставить только строки формата: **одна заглавная буква**, затем `-`, затем **1–3 цифры**. Вывести отфильтрованный список.

### 5) Строки: нормализация пробелов

Дан список строк:
`["  Hello   world  ", "A   B    C", "   one"]`

Задача: для каждой строки убрать пробелы по краям и заменить подряд идущие пробелы внутри на один пробел. Вывести результат.

### 6) Даты: разница между двумя датами

Дан список пар дат (строки `"YYYY-MM-DD"`):
`[("2026-01-01","2026-01-10"), ("2025-12-31","2026-01-01"), ("2026-02-01","2026-01-22")]`

Задача: для каждой пары посчитать разницу в днях (`вторая - первая`) и вывести список чисел.

### 7) Коллекции: группировка по ключу

Дан список строк:
`["math:Ivan", "bio:Olga", "math:Max", "bio:Ivan", "cs:Olga"]`

Задача: построить словарь вида `предмет -> список учеников`, сохранив порядок появления учеников внутри предмета. Вывести словарь.

### 8) Регулярные выражения + даты: извлечение времени из текста

Дан список строк:
`["Start at 2026/01/22 09:14", "No time here", "End: 22-01-2026 18:05"]`

Задача: найти строки, где есть дата и время, извлечь их и привести к формату `"YYYY-MM-DD HH:MM"`. Строки без времени игнорировать.

---


### Задание - проверка расписания

**Сюжет.** Диспетчер космостанции получает журнал событий от робота-курьера. После обновления прошивки логи начали приходить в разных форматах. Нужно привести журнал к единому виду, посчитать время доставки каждой посылки и найти нарушения.

**Входные данные.** Дан список строк `logs`. Каждая строка — одно событие по посылке (ID) со статусом `sent` или `delivered`. Время — с точностью до минут. Строки могут быть в любом порядке.

Логи приходят в одном из трёх форматов.

**Формат A:**
`"2026-01-22 09:14 | ID:042 | STATUS:sent"`

**Формат B:**
`"TS=22/01/2026-09:27; status=delivered; #042"`

**Формат C:**
`"[22.01.2026 09:40] delivered (id:044)"`

Также возможны:

* лишние пробелы (в начале/конце, вокруг разделителей),
* разный регистр (`STATUS`, `status`; `Sent`, `SENT`).

**Требование:** для распознавания форматов и извлечения полей использовать регулярные выражения.

#### Часть 1. Нормализация логов

1. Написать функцию `normalize(line)`, которая принимает строку `line` и возвращает нормализованную запись с полями:

* `dt`: дата-время в виде `"YYYY-MM-DD HH:MM"`
* `id`: целое число (например `42`)
* `status`: строка `"sent"` или `"delivered"` в нижнем регистре

Пример результата:
`{"dt": "2026-01-22 09:27", "id": 42, "status": "delivered"}`

2. Если строка не подходит ни под один формат, функция должна пометить её как «битую» (например вернуть `None`/ошибку/код состояния — как решите) и не ломать программу.

3. Применить `normalize` ко всем строкам из `logs` и получить:

* список нормализованных записей,
* список битых строк (если есть).

#### Часть 2. Расчёт времени доставки

4. Сгруппировать события по `id`. Для каждого `id` найти:

* время отправки (`status = sent`)
* время доставки (`status = delivered`)

5. Для каждого `id` посчитать длительность доставки в минутах: `delivered - sent`.

Условия:

* Если для `id` не хватает одного из событий (`sent` или `delivered`), такой `id` считать «неполным» и вывести отдельно.
* Если `delivered` раньше `sent`, считать это ошибкой времени и вывести отдельно.

#### Часть 3. Отчёт

6. Вывести:

* список всех `id` с длительностью доставки (`id`, минуты), отсортированный по убыванию длительности,
* самый долгий заказ (`id` и минуты),
* список нарушителей правила: доставка должна быть не дольше 20 минут.

#### Дополнительно

A) Устойчивость к «грязным» данным: сделать так, чтобы `normalize` принимал строки вида
`" ts=22/01/2026-09:05; STATUS=Sent; #044  "`
`" [22.01.2026 09:33]   DELIVERED   (ID:045) "`

B) Сводка по часам: посчитать, в какой час суток (00–23) произошло больше всего событий `delivered`.

C) Детектор дублей: если для одного `id` встречается несколько `sent` или несколько `delivered`, вывести такие `id` и количество дублей по каждому статусу.

**Тестовые данные (смешанные форматы):**

```text
logs = [
"2026-01-22 09:14 | ID:042 | STATUS:sent",
"TS=22/01/2026-09:27; status=delivered; #042",
"2026-01-22 09:10 | ID:043 | STATUS:sent",
"2026-01-22 09:18 | ID:043 | STATUS:delivered",
"TS=22/01/2026-09:05; status=sent; #044",
"[22.01.2026 09:40] delivered (id:044)",
"2026-01-22 09:20 | ID:045 | STATUS:sent",
"[22.01.2026 09:33] delivered (id:045)",
"   ts=22/01/2026-09:50; STATUS=Sent; #046   ",
" [22.01.2026 10:05]   DELIVERED   (ID:046) "
]
```

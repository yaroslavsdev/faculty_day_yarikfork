package ru.tbank.education.school.lesson10.practise

/*
### Задание - проверка расписания

**Сюжет.** Диспетчер космостанции получает журнал событий от робота-курьера. После обновления прошивки логи начали приходить в разных форматах. Нужно привести журнал к единому виду, посчитать время доставки каждой посылки и найти нарушения.

**Входные данные.** Дан список строк `logs`. Каждая строка — одно событие по посылке (ID) со статусом `sent` или `delivered`. Время — с точностью до минут. Строки могут быть в любом порядке.

Логи приходят в одном из трёх форматов.

**Формат A:**
`"2026-01-22 09:14 | ID:042 | STATUS:sent"`

**Формат B:**
`"TS=22/01/2026-09:27; status=delivered; #042"`

**Формат C:**
`"[22.01.2026 09:40] delivered (id:044)"`

Также возможны:

* лишние пробелы (в начале/конце, вокруг разделителей),
* разный регистр (`STATUS`, `status`; `Sent`, `SENT`).

**Требование:** для распознавания форматов и извлечения полей использовать регулярные выражения.

#### Часть 1. Нормализация логов

1. Написать функцию `normalize(line)`, которая принимает строку `line` и возвращает нормализованную запись с полями:

* `dt`: дата-время в виде `"YYYY-MM-DD HH:MM"`
* `id`: целое число (например `42`)
* `status`: строка `"sent"` или `"delivered"` в нижнем регистре

Пример результата:
`{"dt": "2026-01-22 09:27", "id": 42, "status": "delivered"}`

2. Если строка не подходит ни под один формат, функция должна пометить её как «битую» (например вернуть `None`/ошибку/код состояния — как решите) и не ломать программу.

3. Применить `normalize` ко всем строкам из `logs` и получить:

* список нормализованных записей,
* список битых строк (если есть).

#### Часть 2. Расчёт времени доставки

4. Сгруппировать события по `id`. Для каждого `id` найти:

* время отправки (`status = sent`)
* время доставки (`status = delivered`)

5. Для каждого `id` посчитать длительность доставки в минутах: `delivered - sent`.

Условия:

* Если для `id` не хватает одного из событий (`sent` или `delivered`), такой `id` считать «неполным» и вывести отдельно.
* Если `delivered` раньше `sent`, считать это ошибкой времени и вывести отдельно.

#### Часть 3. Отчёт

6. Вывести:

* список всех `id` с длительностью доставки (`id`, минуты), отсортированный по убыванию длительности,
* самый долгий заказ (`id` и минуты),
* список нарушителей правила: доставка должна быть не дольше 20 минут.

#### Дополнительно

A) Устойчивость к «грязным» данным: сделать так, чтобы `normalize` принимал строки вида
`" ts=22/01/2026-09:05; STATUS=Sent; #044  "`
`" [22.01.2026 09:33]   DELIVERED   (ID:045) "`

B) Сводка по часам: посчитать, в какой час суток (00–23) произошло больше всего событий `delivered`.

C) Детектор дублей: если для одного `id` встречается несколько `sent` или несколько `delivered`, вывести такие `id` и количество дублей по каждому статусу.

**Тестовые данные (смешанные форматы):**

```text
logs = [
"2026-01-22 09:14 | ID:042 | STATUS:sent",
"TS=22/01/2026-09:27; status=delivered; #042",
"2026-01-22 09:10 | ID:043 | STATUS:sent",
"2026-01-22 09:18 | ID:043 | STATUS:delivered",
"TS=22/01/2026-09:05; status=sent; #044",
"[22.01.2026 09:40] delivered (id:044)",
"2026-01-22 09:20 | ID:045 | STATUS:sent",
"[22.01.2026 09:33] delivered (id:045)",
"   ts=22/01/2026-09:50; STATUS=Sent; #046   ",
" [22.01.2026 10:05]   DELIVERED   (ID:046) "
]
```
*/

fun normalize(log: String): String {
    var str: String = log
    str = str.lowercase()
    return str
}

fun main() {
    val logs = mutableListOf<String>()
    while (true) {
        val inputLine: String? = readlnOrNull()
        if (inputLine == null) {
            break
        } else {
            logs.add(inputLine)
        }
    }

    val normalized = logs.map { normalize(it) }
}